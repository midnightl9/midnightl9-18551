<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Midnight Boss Timer</title>
<style>
  :root{
    --bg:#0b0b0d;
    --panel:#111113;
    --text:#f1f1f1;
    --muted:#b9b9bd;
    --gold:#d4a63f;
    --btn-bg:#18181b;
    --red:#ff4c4c;
  }

  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  h1{margin:20px 16px 6px;font-size:22px}
  .section{padding:0 16px 22px}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0 14px}
  .input,.btn{
    height:30px;border-radius:8px;border:1px solid rgba(255,255,255,.12);
    background:#0f0f12;color:var(--text);padding:0 10px;outline:none;
    font-size:13px;
  }
  .input::placeholder{color:#8f8f95}
  .btn{background:#27324a;border-color:#27324a;color:#fff;font-weight:600;cursor:pointer}
  .btn:hover{filter:brightness(1.05)}

  /* ~50% smaller cards/grid */
  .grid{display:grid;gap:10px;grid-template-columns:repeat(auto-fill,minmax(140px,1fr))}

  .card{
    background:var(--panel);
    border:2px solid var(--gold);
    border-radius:8px;
    padding:9px 8px;
    box-shadow:0 0 0 1px rgba(212,166,63,.15), 0 0 14px rgba(255,207,102,.12);
    transition:box-shadow .3s,border-color .3s,transform .2s;
    text-align:center;
  }
  .card:hover{ transform: translateY(-1px); box-shadow:0 0 0 1px rgba(212,166,63,.25), 0 0 18px rgba(255,207,102,.18); }

  .title{
    margin:0 0 6px;
    font-size:12px; letter-spacing:.08em; text-transform:uppercase;
    color:#f2e6c9;
  }
  .time{
    font-size:17px; font-weight:800; letter-spacing:.12em; margin:2px 0 6px;
    color:#ffffff; transition:color .3s ease;
  }
  .next{
    font-size:10px; letter-spacing:.12em; color:#d7d7db; text-transform:uppercase; margin-bottom:8px;
  }

  .row{display:flex;flex-direction:column;gap:6px;align-items:center; margin:8px 0 2px}

  .pill{
    width:110px; height:26px;
    border-radius:8px;
    border:1.5px solid var(--gold);
    background:transparent;
    color:#e8e0cd;
    text-align:center;
    font-size:11px;
    outline:none;
  }
  .pill::placeholder{color:#8f8f95}
  .pill[type="time"]::-webkit-calendar-picker-indicator,
  .pill[type="date"]::-webkit-calendar-picker-indicator{
    filter: invert(0.8) sepia(0.4) saturate(4) hue-rotate(-20deg);
  }

  .btn-gold{
    min-width:110px;
    height:26px;
    border-radius:8px;
    background:var(--btn-bg);
    color:#f6e7bf;
    border:1.5px solid var(--gold);
    cursor:pointer; font-weight:700;
    font-size:11px;
  }
  .btn-gold:hover{ box-shadow:0 0 12px rgba(255,207,102,.12); }

  .muted{color:var(--muted); font-size:10.5px}

  /* ✅ Keep warning styling but STATIC (no pulse animation) */
  .lowtime{
    border-color:var(--red) !important;
    box-shadow:0 0 0 1px rgba(255,76,76,.25), 0 0 14px rgba(255,76,76,.28) !important;
  }
  .card.lowtime .time{ color:var(--red); }

  /* ✅ removed pulse keyframes + removed .urgent animation entirely */

  hr.sep{border:none;height:1px;background:linear-gradient(90deg,transparent,#34312a,transparent);margin:18px 0}
</style>
</head>
<body>

  <div class="section">
    <h1>Manual Boss Timers</h1>
    <div class="toolbar">
      <input id="m-name" class="input" placeholder="Boss Name" />
      <input id="m-hours" class="input" type="number" min="1" placeholder="Hours" />
      <button id="m-add" class="btn">Add Manual Timer</button>
    </div>
    <div id="manual-grid" class="grid"></div>
  </div>

  <hr class="sep" />

  <div class="section">
    <h1>Scheduled Bosses</h1>
    <div class="toolbar">
      <input id="s-name" class="input" placeholder="Boss Name" />
      <input id="s-sched" class="input" style="min-width:320px" placeholder="Schedule e.g. mon 12:30, tue 19:00" />
      <button id="s-add" class="btn">Add Scheduled Boss</button>
    </div>
    <div id="sched-grid" class="grid"></div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import { getDatabase, ref, get, update, onValue, runTransaction }
      from "https://www.gstatic.com/firebasejs/12.7.0/firebase-database.js";

    /* ========================= Firebase setup ========================= */
    const firebaseConfig = {
      apiKey: "AIzaSyAO9Rc_JH4fN7zk80iNBjdLTxe2xDZ2yLI",
      authDomain: "midnightl9-18551.firebaseapp.com",
      databaseURL: "https://midnightl9-18551-default-rtdb.firebaseio.com",
      projectId: "midnightl9-18551",
      storageBucket: "midnightl9-18551.firebasestorage.app",
      messagingSenderId: "288936534734",
      appId: "1:288936534734:web:3190b89a28bbec8147e69f"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const STATE_REF = ref(db, "bossTimers/default");

    async function fbLoadState() {
      const snap = await get(STATE_REF);
      return snap.exists() ? snap.val() : null;
    }
    async function fbSaveState(data) { await update(STATE_REF, data); }
    function fbListenState(cb) { return onValue(STATE_REF, snap => cb(snap.exists() ? snap.val() : null)); }
    async function fbInitIfMissing(initialState) {
      await runTransaction(STATE_REF, current => (current === null ? initialState : undefined));
    }

    let APPLYING_REMOTE = false;
    let HAS_REMOTE_STATE = false;

    /* ========================= Utilities ========================= */
    const pad2 = n => n.toString().padStart(2,"0");
    const fmtHMS = ms => {
      const s = Math.max(0, Math.floor(ms/1000));
      const h = Math.floor(s/3600);
      const m = Math.floor((s%3600)/60);
      const sec = s%60;
      return `${pad2(h)}:${pad2(m)}:${pad2(sec)}`;
    };
    const fmtTime = d => d.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    const fmtRespawn = ms => fmtTime(new Date(ms));

    /* ====================== Manual Timers ======================= */
    const M_KEY="manual_gold_style_v1";
    const DEFAULT_MANUAL=[
      ["Venatus",10],["Viorent",10],["Ego",21],["Livera",24],["Araneo",24],
      ["Undomiel",24],["Lady Dalia",18],["General Aquleus",29],["Amentis",29],["Baron Braudmore",32],
      ["Wannitas",48],["Metus",48],["Duplican",48],["Shuliar",35],["Gareth",32],
      ["Titore",37],["Larba",35],["Catena",35]
    ];

    function mLoad(){
      const raw = localStorage.getItem(M_KEY);
      if(!raw){
        const now = Date.now();
        return DEFAULT_MANUAL.map(([name,h])=>({name,hours:h,end:now+h*3600*1000,last:"—"}));
      }
      try { return JSON.parse(raw); } catch { return []; }
    }

    let M_STATE = mLoad();
    const mGrid = document.getElementById("manual-grid");

    function mSave(){
      localStorage.setItem(M_KEY, JSON.stringify(M_STATE));
      if (APPLYING_REMOTE) return;
      if (!HAS_REMOTE_STATE) return;
      fbSaveState({ manual: M_STATE }).catch(console.warn);
    }

    window.mRestart = function mRestart(i){
      const it = M_STATE[i];
      it.end = Date.now() + it.hours*3600*1000;
      it.last = new Date().toLocaleString();
      mSave(); mRender(true);
    }

    window.mSetKill = function mSetKill(i){
      const card = document.querySelector(`[data-mcard="${i}"]`);
      const t = card.querySelector('[data-mtime]').value;
      const d = card.querySelector('[data-mdate]').value;
      if(!t || !d) return alert("Pick both time and date.");
      const kill = new Date(`${d}T${t}`);
      if(isNaN(kill)) return alert("Invalid time/date.");
      M_STATE[i].end = kill.getTime() + M_STATE[i].hours*3600*1000;
      M_STATE[i].last = new Date().toLocaleString();
      mSave(); mRender(true);
    }

    window.mSetNext = function mSetNext(i){
      const card = document.querySelector(`[data-mcard="${i}"]`);
      const t = card.querySelector('[data-mtime]').value;
      const d = card.querySelector('[data-mdate]').value;
      if(!t || !d) return alert("Pick both time and date.");
      const dt = new Date(`${d}T${t}`);
      if(isNaN(dt)) return alert("Invalid time/date.");
      M_STATE[i].end = dt.getTime();
      M_STATE[i].last = new Date().toLocaleString();
      mSave(); mRender(true);
    }

    function mCardHTML(it,i){
      const left = it.end - Date.now();
      return `
        <div class="card" data-mcard="${i}">
          <h3 class="title">${it.name}</h3>
          <div class="time" data-mi="${i}">${fmtHMS(left)}</div>
          <div class="next">NEXT: <strong>${fmtRespawn(it.end)}</strong></div>

          <div class="row">
            <input class="pill" type="time" data-mtime />
            <input class="pill" type="date" data-mdate />
          </div>

          <div class="row" style="gap:6px;">
            <button class="btn-gold" onclick="mRestart(${i})">Killed Now</button>
            <button class="btn-gold" onclick="mSetKill(${i})">Set Kill</button>
            <button class="btn-gold" onclick="mSetNext(${i})">Set Next</button>
          </div>

          <div class="muted" style="margin-top:8px">Last restart: ${it.last}</div>
        </div>
      `;
    }

    function mSortedIndices(){
      const now = Date.now();
      return M_STATE.map((_, i) => i)
        .sort((a,b) => ((M_STATE[a].end - now) - (M_STATE[b].end - now)));
    }

    // ✅ render only when needed (not every second)
    let mLastOrderKey = "";
    function mRender(force=false){
      const order = mSortedIndices();
      const key = order.join(",");
      if(!force && key === mLastOrderKey) return;
      mLastOrderKey = key;
      mGrid.innerHTML = order.map(i => mCardHTML(M_STATE[i], i)).join("");
    }
    mRender(true);

    // ✅ tick updates ONLY text + warning classes (no DOM rebuild)
    setInterval(()=>{
      const now = Date.now();
      document.querySelectorAll('[data-mi]').forEach(el=>{
        const i = +el.dataset.mi;
        const left = (M_STATE[i]?.end ?? now) - now;
        el.textContent = fmtHMS(left);

        const card = el.closest('.card');
        if(!card) return;

        if(left <= 3600000) card.classList.add('lowtime'); else card.classList.remove('lowtime');

        const nextEl = card.querySelector('.next strong');
        if(nextEl) nextEl.textContent = fmtRespawn(M_STATE[i].end);
      });
    },1000);

    // ✅ re-sort periodically (doesn't interrupt dropdowns constantly)
    setInterval(()=> mRender(false), 10000);

    document.getElementById("m-add").addEventListener("click", () => {
      const name = document.getElementById("m-name").value.trim();
      const hours = parseFloat(document.getElementById("m-hours").value);
      if(!name) return alert("Enter a boss name.");
      if(!hours || hours <= 0) return alert("Enter hours > 0.");

      const now = Date.now();
      M_STATE.push({ name, hours, end: now + hours*3600*1000, last: new Date().toLocaleString() });

      document.getElementById("m-name").value = "";
      document.getElementById("m-hours").value = "";

      mSave();
      mRender(true);
    });

    /* ===================== Scheduled Timers ===================== */
    const S_KEY="scheduled_gold_style_v1";
    const DAY_MAP={sun:0,mon:1,tue:2,wed:3,thu:4,fri:5,sat:6};

    function parseSchedule(s){
      if(!s) return [];
      return s.split(",").map(x=>x.trim()).filter(Boolean).map(p=>{
        const m=p.match(/^([a-z]{3})\s+(\d{1,2}):(\d{2})(?:\s*(am|pm))?$/i);
        if(!m) return null;
        const day=DAY_MAP[m[1].toLowerCase()];
        let h=parseInt(m[2],10), minute=parseInt(m[3],10);
        const ap=(m[4]||"").toLowerCase();
        if(ap==="pm"&&h!==12)h+=12; if(ap==="am"&&h===12)h=0;
        if(day==null||h>23||minute>59) return null;
        return {day,hour:h,minute};
      }).filter(Boolean);
    }

    function nextFromSchedule(list, now=new Date()){
      if(!list.length) return null;
      let best=null;
      for(const e of list){
        const cand=new Date(now);
        cand.setHours(e.hour,e.minute,0,0);
        const diff=(e.day-now.getDay()+7)%7;
        cand.setDate(cand.getDate()+diff);
        if(cand<=now) cand.setDate(cand.getDate()+7);
        if(!best || cand < best) best = cand;
      }
      return best;
    }

    const DEFAULT_SCHED=[
      {name:"Climantis", scheduleStr:"mon 11:30, thu 19:00"},
      {name:"Saphirus",  scheduleStr:"sun 17:00, tue 11:30"},
      {name:"Neutro",    scheduleStr:"tue 19:00, thu 11:30"},
      {name:"Thymele",   scheduleStr:"mon 19:00, wed 11:30"},
      {name:"Milavy",    scheduleStr:"sat 15:00"},
      {name:"Ringor",    scheduleStr:"sat 17:00"},
      {name:"Roderick",  scheduleStr:"fri 19:00"},
      {name:"Auraq",     scheduleStr:"sun 21:00, wed 21:00"},
    ];

    function sLoad(){
      const raw=localStorage.getItem(S_KEY);
      if(!raw) return DEFAULT_SCHED.map(o=>({...o, schedule:parseSchedule(o.scheduleStr), nextOverride:null}));
      try{
        const arr=JSON.parse(raw);
        return arr.map(o=>({...o, schedule:parseSchedule(o.scheduleStr)}));
      }catch{return []}
    }

    let S_STATE = sLoad();
    const sGrid = document.getElementById("sched-grid");

    function sSave(){
      const payload = S_STATE.map(({name,scheduleStr,nextOverride})=>({name,scheduleStr,nextOverride}));
      localStorage.setItem(S_KEY, JSON.stringify(payload));
      if (APPLYING_REMOTE) return;
      if (!HAS_REMOTE_STATE) return;
      fbSaveState({ scheduled: payload }).catch(console.warn);
    }

    function nextFor(i, now=new Date()){
      return S_STATE[i].nextOverride ? new Date(S_STATE[i].nextOverride) : nextFromSchedule(S_STATE[i].schedule, now);
    }

    window.sSetNext = function sSetNext(i){
      const card = document.querySelector(`[data-scard="${i}"]`);
      const t = card.querySelector('[data-stime]').value;
      const d = card.querySelector('[data-sdate]').value;
      if(!t || !d) return alert("Pick both time and date.");
      const dt = new Date(`${d}T${t}`);
      if(isNaN(dt)) return alert("Invalid time/date.");
      S_STATE[i].nextOverride = dt.toISOString();
      sSave(); sRender(true);
    }

    function sCardHTML(it,i){
      const nxt = nextFor(i, new Date()) || new Date(Date.now()+3600*1000);
      const left = nxt - new Date();
      return `
        <div class="card" data-scard="${i}">
          <h3 class="title">${it.name}</h3>
          <div class="time" data-si="${i}">${fmtHMS(left)}</div>
          <div class="next">NEXT: <strong>${fmtTime(nxt)}</strong></div>

          <div class="row">
            <input class="pill" type="time" data-stime />
            <input class="pill" type="date" data-sdate />
          </div>

          <div class="row" style="gap:6px;">
            <button class="btn-gold" onclick="sSetNext(${i})">Set Next</button>
          </div>

          <div class="muted" style="margin-top:8px">Schedule: ${it.scheduleStr}</div>
        </div>
      `;
    }

    function sSortedIndices(now=new Date()){
      return S_STATE.map((_, i) => i).sort((a,b) => {
        const na = nextFor(a, now) || new Date(now.getTime()+3600*1000);
        const nb = nextFor(b, now) || new Date(now.getTime()+3600*1000);
        return (na - now) - (nb - now);
      });
    }

    let sLastOrderKey = "";
    function sRender(force=false){
      const now = new Date();
      const order = sSortedIndices(now);
      const key = order.join(",");
      if(!force && key === sLastOrderKey) return;
      sLastOrderKey = key;
      sGrid.innerHTML = order.map(i => sCardHTML(S_STATE[i], i)).join("");
    }
    sRender(true);

    setInterval(()=>{
      const now = new Date();
      document.querySelectorAll('[data-si]').forEach(el=>{
        const i = +el.dataset.si;
        const nxt = nextFor(i, now) || new Date(now.getTime()+3600*1000);
        const delta = nxt - now;
        el.textContent = fmtHMS(delta);

        const card = el.closest('.card');
        if(card){
          if(delta <= 3600000) card.classList.add('lowtime'); else card.classList.remove('lowtime');
          const nextEl = card.querySelector('.next strong');
          if(nextEl) nextEl.textContent = fmtTime(nxt);
        }
      });
    },1000);

    // re-sort periodically
    setInterval(()=> sRender(false), 10000);

    document.getElementById("s-add").addEventListener("click", () => {
      const name = document.getElementById("s-name").value.trim();
      const scheduleStr = document.getElementById("s-sched").value.trim();
      if(!name) return alert("Enter a boss name.");
      const schedule = parseSchedule(scheduleStr);
      if(!schedule.length) return alert("Invalid schedule. Example: mon 12:30, tue 19:00");

      S_STATE.push({ name, scheduleStr, schedule, nextOverride: null });

      document.getElementById("s-name").value = "";
      document.getElementById("s-sched").value = "";

      sSave();
      sRender(true);
    });

    /* =========================================================
       ✅ FIREBASE: Load on startup + realtime updates
       ========================================================= */
    (async function firebaseRealtimeSync(){
      function applyRemote(remote){
        if(!remote) return;

        APPLYING_REMOTE = true;
        HAS_REMOTE_STATE = true;

        if (Array.isArray(remote.manual)) {
          M_STATE = remote.manual;
          localStorage.setItem(M_KEY, JSON.stringify(M_STATE));
          mRender(true);
        }

        if (Array.isArray(remote.scheduled)) {
          S_STATE = remote.scheduled.map(o => ({
            ...o,
            schedule: parseSchedule(o.scheduleStr || "")
          }));
          const payload = S_STATE.map(({name,scheduleStr,nextOverride})=>({name,scheduleStr,nextOverride}));
          localStorage.setItem(S_KEY, JSON.stringify(payload));
          sRender(true);
        }

        APPLYING_REMOTE = false;
      }

      try {
        const remote = await fbLoadState();

        if(remote && (remote.manual || remote.scheduled)){
          applyRemote(remote);
        } else {
          const initial = {
            manual: M_STATE,
            scheduled: S_STATE.map(({name,scheduleStr,nextOverride})=>({name,scheduleStr,nextOverride}))
          };
          await fbInitIfMissing(initial);
          HAS_REMOTE_STATE = true;
        }

        fbListenState((live) => applyRemote(live));
      } catch (e) {
        console.warn("Firebase sync failed, using localStorage only.", e);
      }
    })();
  </script>

</body>
</html>
